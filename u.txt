navigation
    ----

cmake
    ----debug
    ----release

boost
    ----static

connect
    ----signal need to connect to a function
        ----when connected to, should specify param placeholder(that means we are using a bind)
        ----常将connect这个语句封装一下，成为一个函数
            ----这函数接收的参数为一个函数，参数可用bind一下，参数可以只有占位符
            ----函数参数的个数可以与信号发出的参数的个数不相等，但bind占位符的个数需要与它相等
        ----signal具体是boost::signal2::signal<type of callback func> signalName
        ----绑定的是一个函数的地址，不是函数

    ----when signal stricked, function were called


    ----导航的开始函数实现的功能是这样的：
        ----首先，可通过传感器获得当前的位置，也就是二维坐标
        ----可找出离当前位置最近的设定点
        ----计算出当前位置与最近设定点的距离
            ----如果过大>1.2，则将它当做一个目标，并使机器正对该目标
                ----过程是将一个函数连接一个信号，这个函数的作用就是始终使方向正对该目标
                    ----当目标距离小于一定值<0.8的时候，再断开与该信号的连接
                ----如果障碍物距离太小，则返回，不进行旋转操作
            ----如果足够小，则就当当前已经在那个设置点上了，通过最短路径算法找出下一个点，并走上面那一套路径（距离过大的时，将它作为一个目标）
                ----一个特殊情况
                      ----如果已经到达最终的点，则停下，否则再算出下一个点
        ----这函数的功能好像只能控制转向，并不能控制走多远
            ----也许这个模块的功能只是控制转向 
        ---- 


    ----statecontrol
        ----应该这里是提供机器人向前走得功能
            ----这里是一个单列
        ----这里调用所有的运动函数
        ----首先，state类里面有一个statecontrol指针
        ----然后statecontrol里面有四个state指针
            ----其中三个是三个状态
            ----一个是一个变量，可以存放前面三个状态中的一个
     ----使用statecontrol控制运动时，要调用当前状态指针中的Event方法，该方法实际上是调用本类私有robot变量的公有成员函数实现的
         ----总感觉这里有点绕
         ----目前还不知道这样做有什么好处

伪陀螺
    ----这个类最终就是用来维护一个二维角度值的
        ----当要实现某种复杂的算法的时候还是新建一个类来写靠谱些
    _onStateChanged
        ----每改变一次状态，陀螺里面的角度传感器数据更新一次
            ----这个函数由别的类里面的onRunCommand触发
            ----每次执行指令时，statecontrol里面的onRunCommand将会发出一个信号供伪陀螺这边的_onStateChanged处理
            ----如果当前是旋转或停止状态，要将点列表中的状态清空，因为这些点是用来拟合直线的，所以只能收集一次直线行走的点
        ----改变状态后，如果是旋转，就需要更新传感器的角度
    _onLocaltionChanged
        ----这个函数里面最后发出了角度改变的信号，这个信号触发了自身函数的再次调用
        ----但什么地方是第一次触发这个函数的，目前还没有找到

{
神经网络算法中间的参数究竟怎么确定？
方法一：
    继续在网上搜文档
    好像所有的神经网络算法都没有告诉怎么确定中间层各个参数是怎样生成的
    好像找到了权值的计算方法了：下面网址文档中的第49页
        ----http://max.book118.com/html/2015/1123/29977580.shtm
    BP神经网络算法：
        ----神经网络训练是根据对训练样本的学习来调整网络连接权值
        ----初始时刻，各节点的的联接权值是杂乱无章的
        ----    ----只能通过
        ----当一个测试样本通过网络，网络的权值就进行了一次调整
            ----于是将第二个样本输入到前一次调整过后的网络，又可以得到第二个实际输出值和期望值之间的误差 
            ----继而继续调整网络，通过不断输入训练样本，网络权值也在不停的调整
            ----当输入任何一个样本，网络的输出误差都控制在一个期望的范畴字中之时，表示网络训练完成。
    BP算法推导
       ----采用误差法相调节方式调价网络
    
算法推导过程：这研究论文还整U币好确定是什么问题：只能进行下一不分析：
首先算出一个期望值，
    -----这应该是第一层里面可定有很多子：
    ----第二个参数是一个去去求和的值的一半，好像没有指定求和的

    
http://www.tuicool.com/articles/ba63eqB
     ----这个网页是讲MLP的


xiawuhaokun va,bejiul lie 
xiaolu jiu chabuduo le 


方法二：
    继续猜
方法三：
    通过看代码是否有文档、注释来确定
}


问题1
    ----导航和避障两者都会用到控制机器旋转，两者会不会发生冲突
问题2
    ----避障每次都向前走1m，会不会发生走过头的情况
问题3
    ----避障走直线，导航旋转，两者之间会不会发生冲突
        ----也就是说，会不会发生时刻都在旋转的问题
            ----这个不会，因为导航的旋转要在机器与固定方向形成一定夹角后才会旋转






{
aux_source_directory(不带双引号的相对路径 变量名称)
    ----这时，变量名称的值将是该路径下的所有文件
}















{
cmake与脚本一样，变量名未申明可以直接使用，比如可为某个列表变量名追加成员，这时该变量就相当于已经声明了

}


























{
用来编译的源文件
    ----aux_source_directory
    ----list

头文件
    ----include_directories
        ----只需要指定安装在系统中的头文件的路径
        ----其它的，在源代码中已经指定好了

链接库目录
    ----link_directories

目标链接库文件
    ----target_link_libraries
}




































{
find_package(Boost COMPONENTS system thread)
    ----用来检查某些线程是否存在
    ----上面是检查Boost,组件中的系统和线程两个模块是否存在
    ----只有包含了某些包，某些包中的内置变量（如某些内置的目录名才能使用）
}


{
基类
    ----在新建的时候，就可以new一个子类赋给基类的指针
        ----可能这样也会涉及到类的隐形转换
        ----还是照我已经形成的观念来比较好
}

{
sign = x>0 ? 1 : (x==0 ? 0 : -1)
}

{
http://www.cnblogs.com/heaad/archive/2011/03/07/1976443.html
    ----神经网络算法简介
}

{
http://blog.csdn.net/huang_xw/article/details/8267500
    ----boost处理字符串相关举例
}

{
boost::to_upper(str)
boost::to_upper_copy(str)
    ----将字符串所有字母变成大写
    ----前者，会改变原字符串
    ----后者，不会改变原字符串，会新生成一个字符串用于返回
}


{
看样子确定报文是否传到下位机的最好确认办法并不是在最后发送之前打印一行日志
    ----而是弄一个终端抓取机，比如：myshock----可能拼错了。
    ----这个包应该最好是从文系统中残神的，要不然就不好办了
}


{
神经网络算法

设置输入数据：
    ----只是设置第0层的神经元的值，不是设置它的权值
    ----第0层也没有权值

GetOutputSignal
    ----取的是最后一层神经元的各x的值

Simulate
    ----触发函数
    ----读满第一层神经元数量的input数据和最后一层神经元数量的target数据后，才调用一次函数
    

PropagateSignal
    ----计算当前层各神经元的x值
        ----也就是产生一个下层神经元的输入信号
        ----所以根据函数名：繁殖信号是可以见名知意的
        ----上层各神经元x的值与本层特定一个神经元的加权值列表相乘，获得一个结果
        ----将该结果乘以以个负的系数[-dGain]作为一个自然指数，再将该值加1取倒数
            ----上面方法得到的值就是当层某神经元的x值

ComputeOutputError
    ----好像最终是用来计算两个标准差的，也就是dMSE和dMAE
    ----将传入的目标值数组中的对应元素与当层对应神经元的x值做差, 也就是获得距离目标的差值
        ----对所有神经元的该差值的平方求和再取平均数就是dMSE
        ----对该差值取绝对值再求平均数就是dMAE
    ----各神经元还有一个误差属性:e, 它的计算方法是：
        ----该差值再与对应神经元的x值的某一表达式：(x * (1-x))相乘
        ----将获得的结果再乘以一个系数：dGain
        ----这个e实际上是用来做反馈的，也就是向后繁殖时会用到

BackPropagateError
    ----当层某个神经元的差值：e 等于下层各神经元差值与当层神经元权值列表的对应元素的乘积之和
        ----不对，得出的这个结果后还要乘以一个x表达式系数和一个dGain系数才是
    ----也就是说，反向反馈错误的时候，可能实际上计算的是这个e值

AdjustWeight
    ----先获得上层神经元对应的x
    ----再获得本层神经元对应的e
    ----再获得本层神经元的dw元素

    ----那么本层的w元素就等于上层的x乘以本层的e 在乘以以个系数：dEta
        ----还要再加上本层的dx 乘以一个系数：dw

    ----需要再重新计算本层的dw
        ----等于上层的x乘以本层的e再乘以一个系数：dEta

Run
   ----Run函数循环调用训练和测试函数：Train Test， 训练和测试函数循环调用触发函数：Simulate
   ----每一次触发函数都要
       ----设置输入信号
       ----繁殖信号
       ----获得输出信号
       ----计算输出误差
       
       如果是处于训练状态，则需要
           ----向后繁殖错误值
           ----调整权重
}

{
opencv中x y轴方向问题
http://www.cnblogs.com/tornadomeet/archive/2012/12/12/2813939.html
}

{
CMAKE_FIND_ROOT_PATH
    ----交叉编译时用到
    ----是一个re-rooted目录
}

{
GodUltraSensor.cpp中的116行，需要补充一下，还有这个地方可能需要加一个锁
}

{
boost::try_to_lock
    这个方法返回 bool 型的值：如果能够获得互斥体则返回true，否则返回 false。
    相比lock函数，try_lock会立即返回，而且在获得互斥体之前不会被阻塞。
}


{
GodMotion
电量信息结构体是否需要加锁问题 g_stBattery
    电量信息现在在运动控制部分还没用到，所以这个问题以后再说

真实速度记录及控制是否需要加锁问题 g_stSpeedMsg
    ----这里是短整型，单个速度是原子操作，但是两个速度一起，可能会造成获得的两个轮子的速度不一样
        ----所以还是有需要同步一下的
        ----但是这里目前看起来还不是致命问题，是小概率事件

假速度记录及读取问题：m_curWheelSpeed[2]
    ----现在用的是互斥锁，必要时需要换成读写锁

超声数据：m_ultrasonicStatus

}


{
命名规则：
http://www.cnblogs.com/ggjucheng/archive/2011/12/15/2289291.html
    类的私有成员变量：以下划线开头
    类的公有成员变量：以m加下划线开头
}


{
isMoving 可能还有些问题：
    ----具体表现是：有时候没在运动，它一直以为当前在运动
        ----可能就是这个问题导致机器有时一直不动
}

{
http://jingyan.baidu.com/article/8ebacdf0cdc64949f75cd555.html
    ----远程登录ubuntu图形界面
}

{
cutecom
    ----ubuntu下的串口调试助手
    ----apt-get就可以安装了
    ----直接敲名字: cutecom就可以运行了
}

{
http://www.ibm.com/developerworks/cn/webservices/ws-soa-capisca1/
    ----c++构建服务
http://www.ibm.com/developerworks/cn/webservices/ws-soa-capisca2/index.html
    ----这是后续第二部分章节

http://blog.csdn.net/wowo1109/article/details/7226777
    ----安卓与c++创建简单services的例子

http://www.educity.cn/develop/479726.html
    ----用VC++建立Service服务应用程序
    ----这个比较简单，可以详细看看

http://www.xuebuyuan.com/1335726.html
    ----这也是一个，可以仔细看看

http://www.2cto.com/os/201204/127211.html
    ----这是脚本方面的，说不定到时候也要参考下

http://biancheng.dnbcw.info/255/255143.html
    ----后台服务程序学习笔记

http://www.cnblogs.com/niocai/archive/2012/07/12/2587736.html
    ----提示在linux什么目录下配置什么东西，也就是程序好了该怎么配置
    ----没有说明别的程序怎么调用这个服务程序中的接口
    ----搜：linux 将一个 程序 变成 一个 服务

http://www.vckbase.com/index.php/wv/1391
    ----vc 中 createservice

搜：
一个 services 多个进程 共用
写一个 linux  service 程序
}

{
http://zsxxsz.iteye.com/blog/2028452
    ----线程池中的惊群现象
}

{
将GodMotion变成一个服务，是需要将它放在后台运行就行了，但是想要调用服务里面的接口，好像是没有现成的，看样子是需要自己实现的
    ----模式是：客户端进程通过include一个共用的接口模块（这个模块是不含有main函数的）与service进行通讯
        ----再由这个共用的接口模块与services与service进行通讯
        ----可见，这个共用的接口模块是有多份拷贝的，但是service只有一个
    ----也就是说接口与services间需要加一个协议
        ----协议就用函数与各参数名之间以下划线分隔就好了，参数也不用参数名标记了
    ----问题是，service返回函数调用结果时，怎么知道该返回到哪个客户端
        ----通讯机制先考虑短连接吧，其实用消息队列也是可以的，不过用短连接拓展性会好一点
        ----如果在报文中不加识别的话，看样子是没办法知道该返回到哪一个客户端的
        ----现在在报文中加一个ip和端口作为识别码 
        ----那么现在的问题就是，在services中怎么保持这个识别码不混淆
            ----进程内motionid是唯一的，只要在入口处将motionid与ip、端口绑定，在出口处再通过motionid查找ip信息就可以处理一来一回的任务了
            ----那么对于signal这种机制在进程间怎么实现呢？
                ----如果通过广播，那么在刚开始时，广播也不知道有多少个对象需要广播
                    ----接口模块刚连接上来时，统一需要加一个注册函数，也就是相当于握一次手
                    ----接口模块需要断开时，统一再握一次手，也就是相当于解除注册，使服务下次广播时少一个对象
    ----所以需要重新使用起来那个socket模块
        ----但是之前是长连接，现在需要改成短连接
        ----我看干脆就用长连接算了，因为通讯次数感觉也是蛮多的（如果实在有必要，后面再改成短连接）
            ----理论上是不能用长连接的，因为若用长连接的话，服务端同时只能保持一个连接，这样就不好了
            ----用短连接也是不好的：比如发一个运动控制指令，那么将要运动完了才会发应答指令，那么这个过程就会比较久，就会造成阻塞
                ----所以现在需要寻求建立多个长连接的方法
        ----幸好之前那个有socket的godmotion版本还没有完全删掉

    ----对于一个进程间共享的服务，必须实现一个代理功能，拿到这个代理就像拿到这个服务本身一样
        ----代理应该也是通过某种继承方式来实现的，因为只有继承才能拿到该类的函数

    ----感觉可以搞一个用来代理的代理程序，由代理程序分配资源，如端口什么的
        ----但是各个客户端程序怎么协调，还是需要一个统一的东西，如文件什么的，但是这样又不太安全
        ----还是靠程序自己去获得端口什么的吧

    ----获得的文件描述符，读写完一次后只要不将它关闭，应该就是长连接了
        ----现在的问题就是，应答回去的时候，需要应答到对应的文件描述符，不能我没发这条指令，你却给我这条指令的应答消息
        ----要实现这种功能，那么请求报文里面就需要携带文件描述符方面的信息，否则上层调用跟本不知道这条请求是从哪来的，更不用说到时应答回来的时候要到哪里去
            ----在通讯这层是根本不知道motionid信息的
            ----请求跟应答之间需要motionid来联系
            ----来回之间需要文件描述符id来联系

    ----看是不是一个文件描述符id就够了
    ----现在函数执行后的返回值已经可以返回给代理端了
        ----只不过目前是放在一个字符串中，这样可能不好，后面还需要改改，将其作为一个独立的整形

    ----还有一个东西需要保证，那就是在每个客户端进程当中，代理的东西要弄成一个单例，要不然发消息到GodMotion时，有可能会被认为是两个客户端

}


{
http://www.2cto.com/kf/201305/209861.html
    ----代理模式
http://www.cnblogs.com/marchtea/archive/2011/12/04/2275194.html
    ----这里似乎也介绍了代理，但是与上面介绍的好像不是一个东西
http://blog.csdn.net/lcl_data/article/details/8989420
    ----各种代理简介
}

{
有空时检查下：signal触发回调函数，当注册的地方是在局部时，
当超出局部作用范围时，是否还能触发回调
刚试了下，好像超出作用范围后也能触发，所以，后面代码还是需要改一下
}

{
select 是用来检查是否有可以读的
对于写socket，是不需要select的，直接写对应的文件描述符就可以了
}


{
收到一个消息后，就开辟一个线程去触发信号，等待别的程序处理完在删除线程，感觉这样是一个解决办法
    ----这样就不需要用全局变量然后再加一堆的锁了
}

{
怎样写出可重用的函数
    ----对于使用单个的全局或成员变量
        ----封装一下对该变量的读，写，在封装中加入锁机制，可以用互斥锁，但最好用读写锁 
    ----对于一个全局数组或成员数组：
        ----看样子也只能像上面一样，不能细分到数组中的元素去加锁，因为若是这样，就会需要加很多个锁
        ----所以全局或成员变量都应封装一下
        ----所以对于类的成员变量，都应该加一个get函数和set函数
        ----所以应该尽量少用全局变量，因为全局变量不方便像类一样加get和set函数，主要是容易混淆
        ----到时候总结了锁机制再来修改这些小类吧，现在先把功能实现先
}

{
http://www.cnblogs.com/weixliu/p/3900764.html
    ----单列，第一次创建时加锁
}

{
对于这种轮询的群组消息，怎么将它依次发送到每个对应的会话当中去呢？
    ----对于这种需求，一种自然而然的想法就是各个会话自己过来取这个轮询的报文信息
        ----但是这是个socket，没法取，因为它只能发送报文，没有自动读取的功能
    ----另一种方法就是主动推送，把所有正在会话的id全找出来，一个一个的去推送消息
        ----但是这种方法也有一定的局限性，因为有些会话它不需要这个信号。
            ----也就是说有些会话比如我的伪终端是不需要这些群组消息的，发过来就会用不着，只会在终端上打印出来而已。
            ----当然也可以控制不在屏幕上面打印，加个条件屏蔽一下就可以了

看样子需要新建一个保存会话id的数组，用来保存所有连接上来的会话id
    ----现在来想想这个数组该建在哪：
        ----是放在SocketComm模块还是放在main函数这个文件中
        ----假设是放在main这个文件中，那么一个新的连接上来后，要在socketComm这个模块通过函数入参传到main这边来了才知道，这样可是可以，但是那个函数是一个指令运行一次的，也就是说会有很多重复的判定，所以说放在main这个模块中不是最好的
        ----现在想想，放在socketcomm这个类里面是最好的了，一个新的连接上来是才判定一次
        ----最好是单独封装成一个类，然后在socketcomm这个类里面创建一个实例，这样是最方便管理的
        ----现在所担心的就是，会话连接到底能不能封装成一个会话数组，并且将它放在一个单独的地方
}

{
http://git.oschina.net/yeahren/libxiaoi_cmake/issues/6
    ----交叉编译
}
