清理一下：
    client通过调用与服务程序一模一样的proxy接口，将符合服务与proxy间协议的报发往服务的通讯模块
        ----其中的报文主要就是三种运动指令
        ----协议格式：
            cmdId:buf
                ----0~9是预留给主动上送报文
                ----cmdId用的是unsigned int
            ----目前协议无长度、校验码信息
         
    服务将返回值报文、运动状态响应报文、主动上送报文将符合协议的报文回送给proxy
        ----协议与请求报文一致

    现在读取socket报文的机制是这样的：
        调用的文件每产生一个新的连接的时候，就生成一个新的线程去调用onReadThread
            ----onReadThread是一个不断select并读取套接字的循环，所以除非连接退出，不然会一直与客户端通讯





#1 改成标准的signal

boost::any型信号发送
boost::tuple<boost::array<char,MAX_PORT_MSG_LEN>, int, unsigned int> params = boost::make_tuple(buf, len, index);
_signal(boost::any(params));
    ----只需要两行
        ----第一行组装信号
        ----第二行发送信号

现在又发现一个问题：
    运动状态反馈时，开始运动和结束运动都会有一个反馈，那么这种情况下，cmdId
motionId sessionId 三元组怎么处理
    ----好像在这种情况下就不好区分了
    ----这种情况下cmdId是一样的 motionId也是一样的 sessionId也是一样的
仔细想想，好像又没有什么问题，不好区分就不好区分，因为我没必要对它们进行区分，我只是
_在命令调用时插入一条记录，在运动状态结束后也就是最后再删除一条记录，对于在中间也就是
_运动开始时的记录，我不需要对它进行增删，我只是查询一下罢了，所以之前的架构还可以保留
  
上周删除idMap的操作还没有调用
    ----也就是说，iDMap中的函数现在只有添加id的函数有调用，删除的函数还没有找到合适的函数调用

现在想想该怎么将运动状态反馈返回给client端
    ----目前在运动状态反馈那个地方，只是将运动状态作为日志打印出来






向客户端传送返回值与传送运动状态反馈的区分：
return   cmdId:buf
feedback cmdId:buf 

----也就是说，只能在buf里面来区分了
----目前函数返回值和运动状态反馈的buf里面都只有一个数字，那就是一个运动Id
    ----只有一个运动Id是无法区分究竟是返回值还是开始运动还是停止运动的

    ----现在来增加点东西，用来区分函数返回值，运动开始，运动结束
        ----不如新的接口就改成这样吧：cmdId:0|1|2_motionId
        ----里面的cmdId，0，1,2什么的都是字符，不是整型

对于非运动指令，是通过cmdId来区分的
    这样感觉还是不太好，比如我调用isMoving，结果如果把返回的信息弄乱了的话，还是不太好的
    
    ----所以还是要另外再加点东西：cmdId:cmdType:buf
        ----如果cmdType是运动相关的，那么buf的最前面就是：0|1|2 分别表示函数调用返回，运动开始，运动结束
        ----如果是isMoving buf就只需要一个数字：0 没有运动， 1 正在运动
    ----一个原则：除了主动上送的，其他的指令的cmdId都是不一样的
        ----但是，在请求报文中，已经有了函数名、参数名作为区分指令类型了，为什么还要加一个标记作为指令类型的区分呢？
            ----可以看做是这样：用指令类型作为大类区分，用函数名作为细类区分.
                ----还有，响应时是不用函数名的，因为响应时不用加函数的参数
                ----之所以请求时用函数名方式而不全用指令类型来区分，是因为需要填写函数的参数，而函数的重载个数是未知的，所以直接写参数名来的直观些
                    ----所以如果全用指令类型的话，那么细分的指令类型就太多了
                ----所以用指令类型+函数名、参数名的方式还是比较科学的。




接口中定义一个connectTo函数
    ----实现时是将某个信号连接到某个函数，到时候不要再给我忘了
    ----返回值是一个函数
        ----return 信号.connect(函数)
    









加日志调试，每次都要重新编译，麻烦
