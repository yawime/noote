清理一下：
    client通过调用与服务程序一模一样的proxy接口，将符合服务与proxy间协议的报发往服务的通讯模块
        ----其中的报文主要就是三种运动指令
        ----协议格式：
            cmdId:buf
                ----0~9是预留给主动上送报文
                ----cmdId用的是unsigned int
            ----目前协议无长度、校验码信息
         
    服务将返回值报文、运动状态响应报文、主动上送报文将符合协议的报文回送给proxy
        ----协议与请求报文一致

    现在读取socket报文的机制是这样的：
        调用的文件每产生一个新的连接的时候，就生成一个新的线程去调用onReadThread
            ----onReadThread是一个不断select并读取套接字的循环，所以除非连接退出，不然会一直与客户端通讯





#1 改成标准的signal

boost::any型信号发送
boost::tuple<boost::array<char,MAX_PORT_MSG_LEN>, int, unsigned int> params = boost::make_tuple(buf, len, index);
_signal(boost::any(params));
    ----只需要两行
        ----第一行组装信号
        ----第二行发送信号

现在又发现一个问题：
    运动状态反馈时，开始运动和结束运动都会有一个反馈，那么这种情况下，cmdId
motionId sessionId 三元组怎么处理
    ----好像在这种情况下就不好区分了
    ----这种情况下cmdId是一样的 motionId也是一样的 sessionId也是一样的
仔细想想，好像又没有什么问题，不好区分就不好区分，因为我没必要对它们进行区分，我只是
_在命令调用时插入一条记录，在运动状态结束后也就是最后再删除一条记录，对于在中间也就是
_运动开始时的记录，我不需要对它进行增删，我只是查询一下罢了，所以之前的架构还可以保留
  
上周删除idMap的操作还没有调用
    ----也就是说，iDMap中的函数现在只有添加id的函数有调用，删除的函数还没有找到合适的函数调用

现在想想该怎么将运动状态反馈返回给client端
    ----目前在运动状态反馈那个地方，只是将运动状态作为日志打印出来







向客户端传送返回值与传送运动状态反馈的区分：
return   cmdId:buf
feedback cmdId:buf 

----也就是说，只能在buf里面来区分了
----目前函数返回值和运动状态反馈的buf里面都只有一个数字，那就是一个运动Id
    ----只有一个运动Id是无法区分究竟是返回值还是开始运动还是停止运动的

    ----现在来增加点东西，用来区分函数返回值，运动开始，运动结束
        ----不如新的接口就改成这样吧：cmdId:0|1|2_motionId
        ----里面的cmdId，0，1,2什么的都是字符，不是整型

对于非运动指令，是通过cmdId来区分的
    这样感觉还是不太好，比如我调用isMoving，结果如果把返回的信息弄乱了的话，还是不太好的
    
    ----所以还是要另外再加点东西：cmdId:cmdType:buf
        ----如果cmdType是运动相关的，那么buf的最前面就是：0|1|2 分别表示函数调用返回，运动开始，运动结束
        ----如果是isMoving buf就只需要一个数字：0 没有运动， 1 正在运动
    ----一个原则：除了主动上送的，其他的指令的cmdId都是不一样的
        ----但是，在请求报文中，已经有了函数名、参数名作为区分指令类型了，为什么还要加一个标记作为指令类型的区分呢？
            ----可以看做是这样：用指令类型作为大类区分，用函数名作为细类区分.
                ----还有，响应时是不用函数名的，因为响应时不用加函数的参数
                ----之所以请求时用函数名方式而不全用指令类型来区分，是因为需要填写函数的参数，而函数的重载个数是未知的，所以直接写参数名来的直观些
                    ----所以如果全用指令类型的话，那么细分的指令类型就太多了
                ----所以用指令类型+函数名、参数名的方式还是比较科学的。



现在来想想是否都已经写完了：
    首先：请求：
        请求是早就写完了的，因为请求不是那么复杂，所以很久了没有再去看请求了，应该没什么问题
    然后：应答
        直接返回的应该也没什么问题
            ----调用一个函数的时候，用同步等待的方式等待函数返回值的返回
        运动状态反馈方面
            ----三种运动类型，两种运动状态，好像涉及到的都考虑到了，应该也没什么问题
        群发消息方面
            ----这里直接是传原始报文的，只不过前面加了一个cmdID，而且是固定值

    现在首先要做的就是加个main文件，编译通，调试通，把架构搞通，最后再来舔砖加瓦
        ----可以将GodMotion里面的那个main文件直接拿来，进行修修改改，应该就可以了
        ----测试方法可以是：开两个伪终端先测试，最后再接入室内导航进行测试
        ----到时候测试时启动服务的方式可能需要定制下，要不然测试还要开两个程序就有点晕


    到时候伪终端也需要改一下，因为伪终端是不经过代理的
        ----所以服务端会有很多消息过来，需要过滤一下
        ----既然伪终端是不经过代理的，那么就可以直接先测试一下了
        ----那么代理这边该怎么来测试呢？
            ----答案就是写个main函数测试一下，在测试的时候，那边服务可以先启动好，然后再进行测试
            ----那么main这边就只能用selfcheck这种方式了，可能测试上会有一点麻烦
                ----也许在proxy这边，也需要做一个调试用的socket服务和另一个伪终端
        














接口中定义一个connectTo函数
    ----实现时是将某个信号连接到某个函数，到时候不要再给我忘了
    ----返回值是一个函数
        ----return 信号.connect(函数)
    








发现一个有意思的东西：
    有些函数接口的入参不是需要传入一个引用吗，这时如果直接在入参处用一个类构造一个对象，这样是不行的，有可能是构造的临时变量不能用作引用
    刚验证了这个问题，果然是真的，也就是说，函数自动构造出来的形式变量（也就是函数的返回值）是不能用作引用的。
    看样子有些这样的细节平时还真不知道啊

{
使用qt的调试模式，以来设置断点
    ----需要在qt的构建模式中的runcmake一项加一个参数，也就是编译时加一个参数
    -----DCMAKE_BUILD_TYPE=Debug
    ----否则设置的断点会无效
}

{
nao 交叉编译的时候需设置的环境变量
export NAO_2_13_CROSS_TOOLCHAIN_PATH=/home/my-ubuntu/Downloads/ctc-linux64-atom-2.1.3.3
export PATH=${PATH}:/home/my-ubuntu/Downloads/ctc-linux64-atom-2.1.3.3/cross/bin
}

{
写一些测试指令集，在伪终端中使用的指令集：
    ----客户端请求指令格式：cmd_id:函数名_参数名_参数值
}


{
关于socket的又一重理解：那个select中的最后一个参数是设置每一次select等待的时间的，如果这个等待时间内没有消息过来，它会执行后续的步骤的
    ----所以需要一个循环来让它重新select
    ----到时候研究一下让程序阻塞在select地方的写法
}

{
看样子配置文件的路径用相对路径有时候还是有很大的局限性：
    1：有些IDE所建的构建路径是与原文件分开的，这时必须将生成的可执行文件与配置文件单独挑出来放到一起或保持 固定的相对关系，这这样程序才能够执行
    2：有时候两个程序会共用一个配置文件，这时配置文件若还是用相对路径，那么这个相对路径就的迎合两个程序对配置文件路径的设定，这样一来，更容易出错

所以以后有关配置文件存放的地方还是得想一个更好的办法，用配置文件的话，两台机器间迁移时，可能需要修改，也会有一点麻烦
    ----看样子还是需要掌握一些系统的内建目录，将配置文件放到系统的内建目录中去，可能这是一种解决办法

使用相对路径还有一个弊端
    ----就是使用qt这种ide在调试模式时，可执行文件是不能改变目录的，这是就只有配置文件改变目录了，这样会产生很多分配置文件副本，这样会看起来很乱
}

{
那个日志函数还有一个问题，那就是多个进程都用那个打印日志的函数时，产生的日志的文件名是一样的，这会导致错乱或覆盖的问题，需要解决下
    ----日志的文件名问题也许可以这样来着手
    ----那就是从构造函数着手
        ----改好后的情况是一个进程将产生一个日志文件，每个进在第一次调用日志函数时，都会调用构造函数，并且这个构造函数是只调用一次的
        ----抓住这个只调用一次的特性就可以产生一个唯一的日志文件
            ----这个日志的文件的文件名到时候也可以放到配置文件里面去

还有一个问题，那就是，如果日志文件在程序运行过程中被删掉，那么现在的情况是：日志将不再产生了，这个原因到时候还要分析一下
}

{
现在的当务之急是解决配置文件的路径问题，因为使用代理模式后，这是一个必须解决的问题，要不然程序就没法运行了
日志的文件名 问题也需要解决一下
}


{
发现了一个编译上的细节
    ----编译时各个源文件放置的顺序其实对程序运行的结果是有影响的
    ----其本质是影响了全局变量的执行顺序
}

{
单列中的非静态成员变量好像不是唯一的
    ----例子就是Trace中的_logFileName变量如果改成非静态的，产生的日志文件名称将是(null).log.日期
    ----这好像与之前是试验有冲突
    ----可能是与静态成员函数不能初始化非静态成员变量有关
        ----无论是直接的还是间接的
}

{
另一个编译上的细节：
    一个源文件在编译的时候，不能够出现两次，否则编译的时候会报错
}

{
cmake中用aux_source_dir来包括目录下的所有的源文件有一个弊端
    ----那就是它们所引用的文件的顺序是按字母顺序排序的
    ----但是，有时候对编译时链接文件的顺序是有要求的，这时候就不合适了
    ----需要找出一种方法，就是包括目录下所有文件，除了指定文件之外
        ----这样就可以将指定文件排在最前或最后，而不会造成文件被编译两次而报错
}

{
服务端的ip端口什么的必须要配到配置文件里去，否则弊端有以下几个：（已修改）
    1：服务端、客户端的地址都写死了，
    2：修改起来不方便，不可能每个客户你都给他们修改一下吧

    3.写代码的态度应该是：每个方面都要将它写到最佳状态，不能是这边过的去就行了
      ----否则到时候别人改进了你又得改
      ----需要以发展的眼光看问题
}


{
现在的情况是：
    ----代理端指令发往服务端后，一直在等待服务端返回值的返回，现在陷入了一个死循环
}
