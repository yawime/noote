清理一下：
    client通过调用与服务程序一模一样的proxy接口，将符合服务与proxy间协议的报发往服务的通讯模块
        ----其中的报文主要就是三种运动指令
        ----协议格式：
            cmdId:buf
                ----0~9是预留给主动上送报文
                ----cmdId用的是unsigned int
            ----目前协议无长度、校验码信息
         
    服务将返回值报文、运动状态响应报文、主动上送报文将符合协议的报文回送给proxy
        ----协议与请求报文一致

    现在读取socket报文的机制是这样的：
        调用的文件每产生一个新的连接的时候，就生成一个新的线程去调用onReadThread
            ----onReadThread是一个不断select并读取套接字的循环，所以除非连接退出，不然会一直与客户端通讯





#1 改成标准的signal

boost::any型信号发送
boost::tuple<boost::array<char,MAX_PORT_MSG_LEN>, int, unsigned int> params = boost::make_tuple(buf, len, index);
_signal(boost::any(params));
    ----只需要两行
        ----第一行组装信号
        ----第二行发送信号

现在又发现一个问题：
    运动状态反馈时，开始运动和结束运动都会有一个反馈，那么这种情况下，cmdId
motionId sessionId 三元组怎么处理
    ----好像在这种情况下就不好区分了
    ----这种情况下cmdId是一样的 motionId也是一样的 sessionId也是一样的
仔细想想，好像又没有什么问题，不好区分就不好区分，因为我没必要对它们进行区分，我只是
_在命令调用时插入一条记录，在运动状态结束后也就是最后再删除一条记录，对于在中间也就是
_运动开始时的记录，我不需要对它进行增删，我只是查询一下罢了，所以之前的架构还可以保留
  
上周删除idMap的操作还没有调用
    ----也就是说，iDMap中的函数现在只有添加id的函数有调用，删除的函数还没有找到合适的函数调用

现在想想该怎么将运动状态反馈返回给client端
    ----目前在运动状态反馈那个地方，只是将运动状态作为日志打印出来







向客户端传送返回值与传送运动状态反馈的区分：
return   cmdId:buf
feedback cmdId:buf 

----也就是说，只能在buf里面来区分了
----目前函数返回值和运动状态反馈的buf里面都只有一个数字，那就是一个运动Id
    ----只有一个运动Id是无法区分究竟是返回值还是开始运动还是停止运动的

    ----现在来增加点东西，用来区分函数返回值，运动开始，运动结束
        ----不如新的接口就改成这样吧：cmdId:0|1|2_motionId
        ----里面的cmdId，0，1,2什么的都是字符，不是整型

对于非运动指令，是通过cmdId来区分的
    这样感觉还是不太好，比如我调用isMoving，结果如果把返回的信息弄乱了的话，还是不太好的
    
    ----所以还是要另外再加点东西：cmdId:cmdType:buf
        ----如果cmdType是运动相关的，那么buf的最前面就是：0|1|2 分别表示函数调用返回，运动开始，运动结束
        ----如果是isMoving buf就只需要一个数字：0 没有运动， 1 正在运动
    ----一个原则：除了主动上送的，其他的指令的cmdId都是不一样的
        ----但是，在请求报文中，已经有了函数名、参数名作为区分指令类型了，为什么还要加一个标记作为指令类型的区分呢？
            ----可以看做是这样：用指令类型作为大类区分，用函数名作为细类区分.
                ----还有，响应时是不用函数名的，因为响应时不用加函数的参数
                ----之所以请求时用函数名方式而不全用指令类型来区分，是因为需要填写函数的参数，而函数的重载个数是未知的，所以直接写参数名来的直观些
                    ----所以如果全用指令类型的话，那么细分的指令类型就太多了
                ----所以用指令类型+函数名、参数名的方式还是比较科学的。



现在来想想是否都已经写完了：
    首先：请求：
        请求是早就写完了的，因为请求不是那么复杂，所以很久了没有再去看请求了，应该没什么问题
    然后：应答
        直接返回的应该也没什么问题
            ----调用一个函数的时候，用同步等待的方式等待函数返回值的返回
        运动状态反馈方面
            ----三种运动类型，两种运动状态，好像涉及到的都考虑到了，应该也没什么问题
        群发消息方面
            ----这里直接是传原始报文的，只不过前面加了一个cmdID，而且是固定值

    现在首先要做的就是加个main文件，编译通，调试通，把架构搞通，最后再来舔砖加瓦
        ----可以将GodMotion里面的那个main文件直接拿来，进行修修改改，应该就可以了
        ----测试方法可以是：开两个伪终端先测试，最后再接入室内导航进行测试
        ----到时候测试时启动服务的方式可能需要定制下，要不然测试还要开两个程序就有点晕


    到时候伪终端也需要改一下，因为伪终端是不经过代理的
        ----所以服务端会有很多消息过来，需要过滤一下
        ----既然伪终端是不经过代理的，那么就可以直接先测试一下了
        ----那么代理这边该怎么来测试呢？
            ----答案就是写个main函数测试一下，在测试的时候，那边服务可以先启动好，然后再进行测试
            ----那么main这边就只能用selfcheck这种方式了，可能测试上会有一点麻烦
                ----也许在proxy这边，也需要做一个调试用的socket服务和另一个伪终端
        














接口中定义一个connectTo函数
    ----实现时是将某个信号连接到某个函数，到时候不要再给我忘了
    ----返回值是一个函数
        ----return 信号.connect(函数)
    








发现一个有意思的东西：
    有些函数接口的入参不是需要传入一个引用吗，这时如果直接在入参处用一个类构造一个对象，这样是不行的，有可能是构造的临时变量不能用作引用
    刚验证了这个问题，果然是真的，也就是说，函数自动构造出来的形式变量（也就是函数的返回值）是不能用作引用的。
    看样子有些这样的细节平时还真不知道啊
